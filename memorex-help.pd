#N canvas 429 186 630 259 10;
#X msg 44 115 3;
#X msg 89 43 1 \, 2 \, 3 \, 4;
#X text 42 98 number;
#X text 162 91 size;
#X obj 53 187 print;
#X msg 159 108 -7;
#X obj 124 82 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000 0 1;
#X text 121 66 replay;
#X text 240 166 'number' \, 'replay' and 'size' can be each sent as
messages to the left input \, each with one argument.;
#X text 103 203 chord;
#X text 240 61 replay: if off (0) \, pass input through to the output
while recording. If on (1) \, replay the buffer in a loop while ignoring
the input except as a trigger.;
#X text 51 204 note;
#X text 240 197 There are two outputs 'note' and 'chord'. 'note' is
just the first element of the 'chord' list. If there are fewer than
six notes in the chord \, the rest are set to zero.;
#X text 115 15 <-chord;
#X text 163 39 <-series;
#X text 163 49 of notes;
#X obj 90 148 memorex 10 4;
#X msg 62 15 5 6 7 8;
#X msg 104 186;
#X text 240 10 Memorex - records input history in a memory buffer of
size 'size'. Input can be a single integer or a list of up to eight
integers \, or fewer if the second object argument is set.;
#X text 240 104 size: (integer) the size of the memory buffer. If positive
\, the buffer is FIFO (first in \, first out). If negative \, the buffer
is LIFO (last in \, first out). Changing it erases the buffer history.
Its initial value can be set as the first object argumment [memorex
size num_chord_notes].;
#X connect 0 0 16 0;
#X connect 1 0 16 0;
#X connect 5 0 16 2;
#X connect 6 0 16 1;
#X connect 16 0 4 0;
#X connect 16 1 18 0;
#X connect 17 0 16 0;
